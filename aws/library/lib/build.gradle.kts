import com.squareup.javapoet.ClassName
import com.squareup.javapoet.CodeBlock
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeSpec
import com.squareup.javapoet.TypeVariableName
import javax.lang.model.element.Modifier

plugins {
  `java-library`
  alias(libs.plugins.maven.publish)
  alias(libs.plugins.spotless)
}

buildscript { dependencies { classpath(libs.javapoet) } }

val mvnGroupId = parent!!.group.toString()
val mvnArtifactId = name
val mvnVersion = parent!!.version.toString()

dependencies {
  implementation(libs.pulumi)
  implementation(libs.jetbrains.annotations)
  implementation("pl.andrzejressel.deeplambdaserialization:lib:$mvnVersion")
}

val generateSerializableFunction by
    tasks.registering {
      outputs.cacheIf { true }
      outputs.dir(layout.buildDirectory.dir("generated/sources/autogenerated"))
      doLast {
        val dir = outputs.files.single().toPath()

        val alphabet = 'A'..'Z'

        val retTypeVariable = TypeVariableName.get("RET")

        val methods =
            (0..alphabet.count()).map { i ->
              val typeVariables = alphabet.take(i).map { TypeVariableName.get(it.toString()) }

              val serializableInputFunction =
                  ParameterizedTypeName.get(
                      ClassName.get(
                          "pl.andrzejressel.deeplambdaserialization.lib",
                          "SerializableInputFunction${i}"),
                      *(listOf(retTypeVariable) + typeVariables).toTypedArray())

              val parameters =
                  alphabet.take(i).map {
                    ParameterSpec.builder(
                            ParameterizedTypeName.get(
                                ClassName.get("com.pulumi.core", "Output"),
                                TypeVariableName.get(it.toString())),
                            "arg${it - 'A' + 1}")
                        .build()
                  }

              val invocation = CodeBlock.join(parameters.map { CodeBlock.of(it.name) }, ", ")

              MethodSpec.methodBuilder("getArgumentsForAWSLambda")
                  .addTypeVariable(retTypeVariable)
                  .addTypeVariables(typeVariables)
                  .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                  .returns(
                      ClassName.get(
                          "pl.andrzejressel.deeplambdaserialization.aws", "LambdaArguments"))
                  .addParameter(serializableInputFunction, "f")
                  .addParameters(parameters)
                  .addStatement(
                      "return handleFunctionN(f, \$T.of(\$L))", List::class.java, invocation)
                  .build()
            }

        val helloWorld: TypeSpec =
            TypeSpec.classBuilder("AWSLib")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethods(methods)
                .superclass(
                    ClassName.get("pl.andrzejressel.deeplambdaserialization.aws", "AbstractAWSLib"))
                .build()

        val javaFile: JavaFile =
            JavaFile.builder("pl.andrzejressel.deeplambdaserialization.aws", helloWorld).build()

        javaFile.writeTo(dir)
      }
    }

sourceSets { main { java { srcDirs(generateSerializableFunction) } } }

mavenPublishing {
  coordinates(mvnGroupId, mvnArtifactId, mvnVersion)

  pom {
    licenses {
      license {
        name = "Gnu Lesser General Public License"
        url = "http://www.gnu.org/licenses/lgpl.txt"
        distribution = "http://www.gnu.org/licenses/lgpl.txt"
      }
    }
  }
}

tasks.test { useJUnitPlatform() }

repositories {
  mavenCentral()
  maven { url = uri("https://s01.oss.sonatype.org/content/repositories/snapshots") }
}
